{"version":3,"file":"popper-base.js","sources":["../../src/dom-utils/getWindow.js","../../src/dom-utils/instanceOf.js","../../src/utils/math.js","../../src/dom-utils/getBoundingClientRect.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getNodeName.js","../../src/dom-utils/getDocumentElement.js","../../src/dom-utils/getWindowScrollBarX.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/isScrollParent.js","../../src/dom-utils/getCompositeRect.js","../../src/dom-utils/getLayoutRect.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/isTableElement.js","../../src/dom-utils/getOffsetParent.js","../../src/enums.js","../../src/utils/orderModifiers.js","../../src/utils/debounce.js","../../src/utils/format.js","../../src/utils/validateModifiers.js","../../src/utils/uniqueBy.js","../../src/utils/getBasePlacement.js","../../src/utils/mergeByName.js","../../src/dom-utils/getViewportRect.js","../../src/dom-utils/getDocumentRect.js","../../src/dom-utils/contains.js","../../src/utils/rectToClientRect.js","../../src/dom-utils/getClippingRect.js","../../src/utils/getVariation.js","../../src/utils/getMainAxisFromPlacement.js","../../src/utils/computeOffsets.js","../../src/utils/getFreshSideObject.js","../../src/utils/mergePaddingObject.js","../../src/utils/expandToHashMap.js","../../src/utils/detectOverflow.js","../../src/createPopper.js"],"sourcesContent":["// @flow\nimport type { Window } from '../types';\ndeclare function getWindow(node: Node | Window): Window;\n\nexport default function getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n","// @flow\nimport getWindow from './getWindow';\n\ndeclare function isElement(node: mixed): boolean %checks(node instanceof\n  Element);\nfunction isElement(node) {\n  const OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\ndeclare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement);\nfunction isHTMLElement(node) {\n  const OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\ndeclare function isShadowRoot(node: mixed): boolean %checks(node instanceof\n  ShadowRoot);\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };\n","// @flow\nexport const max = Math.max;\nexport const min = Math.min;\nexport const round = Math.round;\n","// @flow\nimport type { ClientRectObject, VirtualElement } from '../types';\nimport { isHTMLElement } from './instanceOf';\nimport { round } from '../utils/math';\n\nexport default function getBoundingClientRect(\n  element: Element | VirtualElement,\n  includeScale: boolean = false\n): ClientRectObject {\n  const rect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (isHTMLElement(element) && includeScale) {\n    const offsetHeight = element.offsetHeight;\n    const offsetWidth = element.offsetWidth;\n\n    // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n    // Fallback to 1 in case both values are `0`\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY,\n  };\n}\n","// @flow\nimport getWindow from './getWindow';\nimport type { Window } from '../types';\n\nexport default function getWindowScroll(node: Node | Window) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n\n  return {\n    scrollLeft,\n    scrollTop,\n  };\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport { isHTMLElement } from './instanceOf';\nimport getHTMLElementScroll from './getHTMLElementScroll';\nimport type { Window } from '../types';\n\nexport default function getNodeScroll(node: Node | Window) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\nimport type { Window } from '../types';\n\nexport default function getNodeName(element: ?Node | Window): ?string {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n","// @flow\nimport { isElement } from './instanceOf';\nimport type { Window } from '../types';\n\nexport default function getDocumentElement(\n  element: Element | Window\n): HTMLElement {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return (\n    (isElement(element)\n      ? element.ownerDocument\n      : // $FlowFixMe[prop-missing]\n        element.document) || window.document\n  ).documentElement;\n}\n","// @flow\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getDocumentElement from './getDocumentElement';\nimport getWindowScroll from './getWindowScroll';\n\nexport default function getWindowScrollBarX(element: Element): number {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this 